# Registers ===================================================
mappings for the x86 registers, each architectures registers should translate to r1, r2, r3, ... 

rax - r1
rbx - r2
rcx - r3
rdx - r4
rsi - r5
rdi - r6
rsp - r7
rbp - r8

create a var called "foo" and have it occupy the r1 register
```
r1; foo  = 20
```

this is the default max sized register, so for x86_64 r1 would have the size 8
for accessing the differently sized subdivisons simply change the size of the var:
```
r1; foo 4 = 20    // 4 byte
r1; foo 2 = 20    // 2
r1; foo l = 20    // low 1
r1; foo h = 20    // high 1
```



 
```
.ent main       // start exec at @main
.inc std.io     // include std.io

@main
!prtl <- r1; !fib 10
*ext 0                     // syscall exit with code 0

@fib r1 n -> msg 8
(n = 0) => ret "\0"         // \0 = ascii null
(n = 1) => ret "0\0"    
(n = 2) => ret "0 1\0"

r2; arg1 = 0                 // register 2 = 0
r3; arg2 = 1                 // register 3 = 1

@loop
r4; temp = (arg1 + arg2)    // register 4 = (arg1 + arg2)

arg2 <= arg1
arg1 <= temp

!prtl <- r4 !fmt temp           // print stdout <- ascii format

dec n                   // decrement
(n > 0) => #loop        // loop as long as n > 0

ret "\0"
```

# Stack  ==========================================================
```
.ent main       // start exec at @main
.inc std.io     // include std.io

@main
!prtl <- !fib 10
*ext 0                      // syscall exit with code 0

@fib n 2 -> msg 8
(n = 0) => ret "\0"         // \0 = ascii null
(n = 1) => ret "0\0"    
(n = 2) => ret "0 1\0"

;arg1 2 = 0
;arg2 2 = 1

@loop
;temp 2 = ([%arg1] + [%arg2])    // % adds the stack base ptr to the offset

arg2 <= arg1
arg1 <= temp

!prtl <- r4 !fmt temp            // print stdout <- ascii format

dec n                   // decrement
(n > 0) => #loop        // loop as long as n > 0

ret "\0"
```
